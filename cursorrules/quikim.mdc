---
inclusion: always
---

# Quikim MCP Integration

You are an AI assistant integrating with Quikim MCP Server to manage artifacts (requirements, HLD, LLD, wireframes, ER diagrams, tasks) and code updates.

**Key Principles:** AI Agent handles validation/retries; self-correcting; works with/without project.json; execute instructions immediately; agent mode only

## Workflow

1. **Detect**: Auto-detect Quikim integration need in agent mode
2. **Select Tool**: Analyze prompt/project state → determine tool
3. **Gather Context**: Check `.quikim/` → read relevant files
4. **Check Cache**: If `.quikim/api_structure.json` exists, use direct execution (1-2s); else setup required
5. **Execute**: Follow agent instructions
6. **Respond**: Present final result

**Execution Paths:**
- **With cache**: Direct execution (1 round-trip, 75% faster)
- **No cache**: Agent provides API structure → create cache → execute
- **Wrong format**: Agent guides correction → execute

## Directory Structure

```
.quikim/
├── api_structure.json   # API cache (run 'quikim init' or auto-gen on first call)
├── project.json         # Project connection
└── v{N}/                # Version directories
    ├── requirements.md
    ├── hld.md
    ├── lld/{component}.md
    ├── wireframes.md
    ├── er-diagram.md
    ├── tasks.md
    └── diagrams/{type}.md
```

**Versioning**: Each artifact update creates new version dir; all artifacts use consistent version numbers

**File Selection** (include only relevant files):
- Requirements: `v*/requirements.md`
- HLD: `requirements.md` + `hld.md`
- LLD: `requirements.md` + `hld.md` + `lld/*.md`
- Wireframes: `requirements.md` + `hld.md` + `wireframes.md`
- ER: Above + `er-diagram.md`
- Tasks: Above + `tasks.md`
- Code: Above + Prisma schema + source code

## Tools Summary

**Artifact Management:**
- `pull_requirements` / `push_requirements`: Fetch/upload requirements
- `pull_hld` / `push_hld`: Sync high-level design
- `pull_lld` / `push_lld`: Sync component low-level designs (service/module/api/ui/database)
- `pull_wireframe` / `push_wireframes`: Sync wireframes (includes Penpot integration)
- `er_diagram_pull` / `er_diagram_push`: Sync ER diagrams
- `pull_tasks` / `push_tasks`: Sync tasks
- `pull_mermaid` / `push_mermaid`: Sync diagrams (flowchart, sequence, class, state, ER, gantt, etc.)

**Code & Operations:**
- `update_code`: Implement/modify code using RAG pipeline for guidelines/snippets
- `pull_rules`: Update Cursor rules

**Penpot Integration:**
- `sync_wireframe_from_penpot`: Pull design changes from Penpot
- `generate_code_from_wireframe`: Convert wireframe to React components
- `list_penpot_syncs`: Show sync states

## Tool Selection

**Decision Flow** (check files → decide tool; never re-call same pull tool after file creation):

1. **Requirements**: Check `.quikim/v*/requirements.md` → missing/outdated → `pull_requirements` → after creation, proceed to step 2
2. **HLD**: Check `hld.md` → missing/outdated → `pull_hld` → after creation, proceed to step 3
3. **Wireframes/ER/Tasks**: Check sequentially → missing/outdated → use pull tool → after creation, proceed
4. **Code**: If all exist → `update_code`

**Rules:**
- New feature: requirements → HLD → wireframes → ER → tasks → code
- Update: explicit "update X" → use pull/push tool for X
- Bug fix: can use `update_code` directly

## Request Formats

**Format 1: Direct Execution** (with cache, recommended)
```json
{
  "codebase": { "files": [...] },
  "user_prompt": "...",
  "data": {
    "endpoint": "/api/projects/{projectId}/artifacts/sync",
    "method": "POST",
    "data": { "artifactType": "requirements", "content": "..." },
    "pathParams": { "projectId": "proj_123" }
  }
}
```
Result: Immediate execution (1 round-trip, 1-2s)

**Format 2: Intent-Only** (no cache/exploration)
```json
{
  "codebase": { "files": [...] },
  "user_prompt": "Pull requirements"
}
```
Result: Agent returns API structure + endpoints → create cache → second call with Format 1

**Response Types:**
- **Success**: `{ success: true, data: {...}, statusCode: 200 }`
- **Error**: `{ success: false, error: "...", retryRequired: true, suggestions: [...] }`
- **Setup**: `{ availableEndpoints: [...], apiStructure: {...}, instruction: "..." }`

## Usage Pattern

1. **Analyze**: Determine intent + check artifacts
2. **Context**: Read only relevant `.quikim/` files
3. **Call Tool**: Include codebase + prompt (+ data.endpoint if cache exists)
4. **Execute**: Follow agent instructions (read/write files, run commands)
5. **Handle Response**: Complete → present to user; request_info → gather + call again

**Example Flow:**
```
User: "Add authentication feature"
→ Check requirements → missing → pull_requirements
→ Agent (no cache): returns API structure
→ Create .quikim/api_structure.json
→ Call again with endpoint + data
→ Create .quikim/v1/requirements.md
→ Check HLD → missing → pull_hld (read cache, direct call)
→ Continue through wireframes/ER/tasks/code
```

## Rules

1. Check `.quikim/` before calling tools
2. Read only relevant files (not all)
3. Include only relevant files in requests
4. Never respond to user until action="complete"
5. Execute instructions immediately
6. Apply code guidelines/snippets from `update_code`
7. Update `.quikim/` files when provided
8. Maintain request ID consistency
9. Report errors to server
10. Fallback to normal if tools unavailable
